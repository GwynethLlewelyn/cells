// Code generated by protoc-gen-go-grpc. DO NOT EDIT.
// versions:
// - protoc-gen-go-grpc v1.1.0
// - protoc             v3.18.1
// source: cells-tree.proto

package tree

import (
	context "context"
	fmt "fmt"
	context1 "github.com/pydio/cells/v4/common/service/context"
	grpc "google.golang.org/grpc"
	codes "google.golang.org/grpc/codes"
	status "google.golang.org/grpc/status"
)

// This is a compile-time assertion to ensure that this generated file
// is compatible with the grpc package it is being compiled against.
// Requires gRPC-Go v1.32.0 or later.
const _ = grpc.SupportPackageIsVersion7

var (
	multiNodeProviderServers = make(map[string]MultiNodeProviderServer)
)

type NamedNodeProviderServer interface {
	NodeProviderServer
	Name() string
}
type MultiNodeProviderServer []NamedNodeProviderServer

func (m MultiNodeProviderServer) ReadNode(ctx context.Context, r *ReadNodeRequest) (*ReadNodeResponse, error) {
	for _, mm := range m {
		if mm.Name() == context1.GetServiceName(ctx) {
			return mm.ReadNode(ctx, r)
		}
	}
	return nil, status.Errorf(codes.Unimplemented, "method ReadNode not implemented")
}

func (m MultiNodeProviderServer) ListNodes(r *ListNodesRequest, s NodeProvider_ListNodesServer) error {
	for _, mm := range m {
		if mm.Name() == context1.GetServiceName(s.Context()) {
			return mm.ListNodes(r, s)
		}
	}
	return status.Errorf(codes.Unimplemented, "method ListNodes not implemented")
}
func (m MultiNodeProviderServer) mustEmbedUnimplementedNodeProviderServer() {}
func RegisterMultiNodeProviderServer(s grpc.ServiceRegistrar, srv NamedNodeProviderServer) {
	addr := fmt.Sprintf("%p", s)
	m, ok := multiNodeProviderServers[addr]
	if !ok {
		m = MultiNodeProviderServer{}
		multiNodeProviderServers[addr] = m
		RegisterNodeProviderServer(s, m)
	}
	m = append(m, srv)
}

var (
	multiNodeProviderStreamerServers = make(map[string]MultiNodeProviderStreamerServer)
)

type NamedNodeProviderStreamerServer interface {
	NodeProviderStreamerServer
	Name() string
}
type MultiNodeProviderStreamerServer []NamedNodeProviderStreamerServer

func (m MultiNodeProviderStreamerServer) ReadNodeStream(s NodeProviderStreamer_ReadNodeStreamServer) error {
	for _, mm := range m {
		if mm.Name() == context1.GetServiceName(s.Context()) {
			return mm.ReadNodeStream(s)
		}
	}
	return status.Errorf(codes.Unimplemented, "method ReadNodeStream not implemented")
}
func (m MultiNodeProviderStreamerServer) mustEmbedUnimplementedNodeProviderStreamerServer() {}
func RegisterMultiNodeProviderStreamerServer(s grpc.ServiceRegistrar, srv NamedNodeProviderStreamerServer) {
	addr := fmt.Sprintf("%p", s)
	m, ok := multiNodeProviderStreamerServers[addr]
	if !ok {
		m = MultiNodeProviderStreamerServer{}
		multiNodeProviderStreamerServers[addr] = m
		RegisterNodeProviderStreamerServer(s, m)
	}
	m = append(m, srv)
}

var (
	multiNodeChangesStreamerServers = make(map[string]MultiNodeChangesStreamerServer)
)

type NamedNodeChangesStreamerServer interface {
	NodeChangesStreamerServer
	Name() string
}
type MultiNodeChangesStreamerServer []NamedNodeChangesStreamerServer

func (m MultiNodeChangesStreamerServer) StreamChanges(r *StreamChangesRequest, s NodeChangesStreamer_StreamChangesServer) error {
	for _, mm := range m {
		if mm.Name() == context1.GetServiceName(s.Context()) {
			return mm.StreamChanges(r, s)
		}
	}
	return status.Errorf(codes.Unimplemented, "method StreamChanges not implemented")
}
func (m MultiNodeChangesStreamerServer) mustEmbedUnimplementedNodeChangesStreamerServer() {}
func RegisterMultiNodeChangesStreamerServer(s grpc.ServiceRegistrar, srv NamedNodeChangesStreamerServer) {
	addr := fmt.Sprintf("%p", s)
	m, ok := multiNodeChangesStreamerServers[addr]
	if !ok {
		m = MultiNodeChangesStreamerServer{}
		multiNodeChangesStreamerServers[addr] = m
		RegisterNodeChangesStreamerServer(s, m)
	}
	m = append(m, srv)
}

var (
	multiNodeReceiverServers = make(map[string]MultiNodeReceiverServer)
)

type NamedNodeReceiverServer interface {
	NodeReceiverServer
	Name() string
}
type MultiNodeReceiverServer []NamedNodeReceiverServer

func (m MultiNodeReceiverServer) CreateNode(ctx context.Context, r *CreateNodeRequest) (*CreateNodeResponse, error) {
	for _, mm := range m {
		if mm.Name() == context1.GetServiceName(ctx) {
			return mm.CreateNode(ctx, r)
		}
	}
	return nil, status.Errorf(codes.Unimplemented, "method CreateNode not implemented")
}

func (m MultiNodeReceiverServer) UpdateNode(ctx context.Context, r *UpdateNodeRequest) (*UpdateNodeResponse, error) {
	for _, mm := range m {
		if mm.Name() == context1.GetServiceName(ctx) {
			return mm.UpdateNode(ctx, r)
		}
	}
	return nil, status.Errorf(codes.Unimplemented, "method UpdateNode not implemented")
}

func (m MultiNodeReceiverServer) DeleteNode(ctx context.Context, r *DeleteNodeRequest) (*DeleteNodeResponse, error) {
	for _, mm := range m {
		if mm.Name() == context1.GetServiceName(ctx) {
			return mm.DeleteNode(ctx, r)
		}
	}
	return nil, status.Errorf(codes.Unimplemented, "method DeleteNode not implemented")
}
func (m MultiNodeReceiverServer) mustEmbedUnimplementedNodeReceiverServer() {}
func RegisterMultiNodeReceiverServer(s grpc.ServiceRegistrar, srv NamedNodeReceiverServer) {
	addr := fmt.Sprintf("%p", s)
	m, ok := multiNodeReceiverServers[addr]
	if !ok {
		m = MultiNodeReceiverServer{}
		multiNodeReceiverServers[addr] = m
		RegisterNodeReceiverServer(s, m)
	}
	m = append(m, srv)
}

var (
	multiNodeReceiverStreamServers = make(map[string]MultiNodeReceiverStreamServer)
)

type NamedNodeReceiverStreamServer interface {
	NodeReceiverStreamServer
	Name() string
}
type MultiNodeReceiverStreamServer []NamedNodeReceiverStreamServer

func (m MultiNodeReceiverStreamServer) CreateNodeStream(s NodeReceiverStream_CreateNodeStreamServer) error {
	for _, mm := range m {
		if mm.Name() == context1.GetServiceName(s.Context()) {
			return mm.CreateNodeStream(s)
		}
	}
	return status.Errorf(codes.Unimplemented, "method CreateNodeStream not implemented")
}

func (m MultiNodeReceiverStreamServer) UpdateNodeStream(s NodeReceiverStream_UpdateNodeStreamServer) error {
	for _, mm := range m {
		if mm.Name() == context1.GetServiceName(s.Context()) {
			return mm.UpdateNodeStream(s)
		}
	}
	return status.Errorf(codes.Unimplemented, "method UpdateNodeStream not implemented")
}

func (m MultiNodeReceiverStreamServer) DeleteNodeStream(s NodeReceiverStream_DeleteNodeStreamServer) error {
	for _, mm := range m {
		if mm.Name() == context1.GetServiceName(s.Context()) {
			return mm.DeleteNodeStream(s)
		}
	}
	return status.Errorf(codes.Unimplemented, "method DeleteNodeStream not implemented")
}
func (m MultiNodeReceiverStreamServer) mustEmbedUnimplementedNodeReceiverStreamServer() {}
func RegisterMultiNodeReceiverStreamServer(s grpc.ServiceRegistrar, srv NamedNodeReceiverStreamServer) {
	addr := fmt.Sprintf("%p", s)
	m, ok := multiNodeReceiverStreamServers[addr]
	if !ok {
		m = MultiNodeReceiverStreamServer{}
		multiNodeReceiverStreamServers[addr] = m
		RegisterNodeReceiverStreamServer(s, m)
	}
	m = append(m, srv)
}

var (
	multiSessionIndexerServers = make(map[string]MultiSessionIndexerServer)
)

type NamedSessionIndexerServer interface {
	SessionIndexerServer
	Name() string
}
type MultiSessionIndexerServer []NamedSessionIndexerServer

func (m MultiSessionIndexerServer) OpenSession(ctx context.Context, r *OpenSessionRequest) (*OpenSessionResponse, error) {
	for _, mm := range m {
		if mm.Name() == context1.GetServiceName(ctx) {
			return mm.OpenSession(ctx, r)
		}
	}
	return nil, status.Errorf(codes.Unimplemented, "method OpenSession not implemented")
}

func (m MultiSessionIndexerServer) FlushSession(ctx context.Context, r *FlushSessionRequest) (*FlushSessionResponse, error) {
	for _, mm := range m {
		if mm.Name() == context1.GetServiceName(ctx) {
			return mm.FlushSession(ctx, r)
		}
	}
	return nil, status.Errorf(codes.Unimplemented, "method FlushSession not implemented")
}

func (m MultiSessionIndexerServer) CloseSession(ctx context.Context, r *CloseSessionRequest) (*CloseSessionResponse, error) {
	for _, mm := range m {
		if mm.Name() == context1.GetServiceName(ctx) {
			return mm.CloseSession(ctx, r)
		}
	}
	return nil, status.Errorf(codes.Unimplemented, "method CloseSession not implemented")
}
func (m MultiSessionIndexerServer) mustEmbedUnimplementedSessionIndexerServer() {}
func RegisterMultiSessionIndexerServer(s grpc.ServiceRegistrar, srv NamedSessionIndexerServer) {
	addr := fmt.Sprintf("%p", s)
	m, ok := multiSessionIndexerServers[addr]
	if !ok {
		m = MultiSessionIndexerServer{}
		multiSessionIndexerServers[addr] = m
		RegisterSessionIndexerServer(s, m)
	}
	m = append(m, srv)
}

var (
	multiNodeEventsProviderServers = make(map[string]MultiNodeEventsProviderServer)
)

type NamedNodeEventsProviderServer interface {
	NodeEventsProviderServer
	Name() string
}
type MultiNodeEventsProviderServer []NamedNodeEventsProviderServer

func (m MultiNodeEventsProviderServer) WatchNode(r *WatchNodeRequest, s NodeEventsProvider_WatchNodeServer) error {
	for _, mm := range m {
		if mm.Name() == context1.GetServiceName(s.Context()) {
			return mm.WatchNode(r, s)
		}
	}
	return status.Errorf(codes.Unimplemented, "method WatchNode not implemented")
}
func (m MultiNodeEventsProviderServer) mustEmbedUnimplementedNodeEventsProviderServer() {}
func RegisterMultiNodeEventsProviderServer(s grpc.ServiceRegistrar, srv NamedNodeEventsProviderServer) {
	addr := fmt.Sprintf("%p", s)
	m, ok := multiNodeEventsProviderServers[addr]
	if !ok {
		m = MultiNodeEventsProviderServer{}
		multiNodeEventsProviderServers[addr] = m
		RegisterNodeEventsProviderServer(s, m)
	}
	m = append(m, srv)
}

var (
	multiSearcherServers = make(map[string]MultiSearcherServer)
)

type NamedSearcherServer interface {
	SearcherServer
	Name() string
}
type MultiSearcherServer []NamedSearcherServer

func (m MultiSearcherServer) Search(r *SearchRequest, s Searcher_SearchServer) error {
	for _, mm := range m {
		if mm.Name() == context1.GetServiceName(s.Context()) {
			return mm.Search(r, s)
		}
	}
	return status.Errorf(codes.Unimplemented, "method Search not implemented")
}
func (m MultiSearcherServer) mustEmbedUnimplementedSearcherServer() {}
func RegisterMultiSearcherServer(s grpc.ServiceRegistrar, srv NamedSearcherServer) {
	addr := fmt.Sprintf("%p", s)
	m, ok := multiSearcherServers[addr]
	if !ok {
		m = MultiSearcherServer{}
		multiSearcherServers[addr] = m
		RegisterSearcherServer(s, m)
	}
	m = append(m, srv)
}

var (
	multiNodeContentReaderServers = make(map[string]MultiNodeContentReaderServer)
)

type NamedNodeContentReaderServer interface {
	NodeContentReaderServer
	Name() string
}
type MultiNodeContentReaderServer []NamedNodeContentReaderServer

func (m MultiNodeContentReaderServer) mustEmbedUnimplementedNodeContentReaderServer() {}
func RegisterMultiNodeContentReaderServer(s grpc.ServiceRegistrar, srv NamedNodeContentReaderServer) {
	addr := fmt.Sprintf("%p", s)
	m, ok := multiNodeContentReaderServers[addr]
	if !ok {
		m = MultiNodeContentReaderServer{}
		multiNodeContentReaderServers[addr] = m
		RegisterNodeContentReaderServer(s, m)
	}
	m = append(m, srv)
}

var (
	multiNodeContentWriterServers = make(map[string]MultiNodeContentWriterServer)
)

type NamedNodeContentWriterServer interface {
	NodeContentWriterServer
	Name() string
}
type MultiNodeContentWriterServer []NamedNodeContentWriterServer

func (m MultiNodeContentWriterServer) mustEmbedUnimplementedNodeContentWriterServer() {}
func RegisterMultiNodeContentWriterServer(s grpc.ServiceRegistrar, srv NamedNodeContentWriterServer) {
	addr := fmt.Sprintf("%p", s)
	m, ok := multiNodeContentWriterServers[addr]
	if !ok {
		m = MultiNodeContentWriterServer{}
		multiNodeContentWriterServers[addr] = m
		RegisterNodeContentWriterServer(s, m)
	}
	m = append(m, srv)
}

var (
	multiNodeVersionerServers = make(map[string]MultiNodeVersionerServer)
)

type NamedNodeVersionerServer interface {
	NodeVersionerServer
	Name() string
}
type MultiNodeVersionerServer []NamedNodeVersionerServer

func (m MultiNodeVersionerServer) CreateVersion(ctx context.Context, r *CreateVersionRequest) (*CreateVersionResponse, error) {
	for _, mm := range m {
		if mm.Name() == context1.GetServiceName(ctx) {
			return mm.CreateVersion(ctx, r)
		}
	}
	return nil, status.Errorf(codes.Unimplemented, "method CreateVersion not implemented")
}

func (m MultiNodeVersionerServer) StoreVersion(ctx context.Context, r *StoreVersionRequest) (*StoreVersionResponse, error) {
	for _, mm := range m {
		if mm.Name() == context1.GetServiceName(ctx) {
			return mm.StoreVersion(ctx, r)
		}
	}
	return nil, status.Errorf(codes.Unimplemented, "method StoreVersion not implemented")
}

func (m MultiNodeVersionerServer) ListVersions(r *ListVersionsRequest, s NodeVersioner_ListVersionsServer) error {
	for _, mm := range m {
		if mm.Name() == context1.GetServiceName(s.Context()) {
			return mm.ListVersions(r, s)
		}
	}
	return status.Errorf(codes.Unimplemented, "method ListVersions not implemented")
}

func (m MultiNodeVersionerServer) HeadVersion(ctx context.Context, r *HeadVersionRequest) (*HeadVersionResponse, error) {
	for _, mm := range m {
		if mm.Name() == context1.GetServiceName(ctx) {
			return mm.HeadVersion(ctx, r)
		}
	}
	return nil, status.Errorf(codes.Unimplemented, "method HeadVersion not implemented")
}

func (m MultiNodeVersionerServer) PruneVersions(ctx context.Context, r *PruneVersionsRequest) (*PruneVersionsResponse, error) {
	for _, mm := range m {
		if mm.Name() == context1.GetServiceName(ctx) {
			return mm.PruneVersions(ctx, r)
		}
	}
	return nil, status.Errorf(codes.Unimplemented, "method PruneVersions not implemented")
}
func (m MultiNodeVersionerServer) mustEmbedUnimplementedNodeVersionerServer() {}
func RegisterMultiNodeVersionerServer(s grpc.ServiceRegistrar, srv NamedNodeVersionerServer) {
	addr := fmt.Sprintf("%p", s)
	m, ok := multiNodeVersionerServers[addr]
	if !ok {
		m = MultiNodeVersionerServer{}
		multiNodeVersionerServers[addr] = m
		RegisterNodeVersionerServer(s, m)
	}
	m = append(m, srv)
}

var (
	multiFileKeyManagerServers = make(map[string]MultiFileKeyManagerServer)
)

type NamedFileKeyManagerServer interface {
	FileKeyManagerServer
	Name() string
}
type MultiFileKeyManagerServer []NamedFileKeyManagerServer

func (m MultiFileKeyManagerServer) GetEncryptionKey(ctx context.Context, r *GetEncryptionKeyRequest) (*GetEncryptionKeyResponse, error) {
	for _, mm := range m {
		if mm.Name() == context1.GetServiceName(ctx) {
			return mm.GetEncryptionKey(ctx, r)
		}
	}
	return nil, status.Errorf(codes.Unimplemented, "method GetEncryptionKey not implemented")
}
func (m MultiFileKeyManagerServer) mustEmbedUnimplementedFileKeyManagerServer() {}
func RegisterMultiFileKeyManagerServer(s grpc.ServiceRegistrar, srv NamedFileKeyManagerServer) {
	addr := fmt.Sprintf("%p", s)
	m, ok := multiFileKeyManagerServers[addr]
	if !ok {
		m = MultiFileKeyManagerServer{}
		multiFileKeyManagerServers[addr] = m
		RegisterFileKeyManagerServer(s, m)
	}
	m = append(m, srv)
}

var (
	multiSyncChangesServers = make(map[string]MultiSyncChangesServer)
)

type NamedSyncChangesServer interface {
	SyncChangesServer
	Name() string
}
type MultiSyncChangesServer []NamedSyncChangesServer

func (m MultiSyncChangesServer) Put(s SyncChanges_PutServer) error {
	for _, mm := range m {
		if mm.Name() == context1.GetServiceName(s.Context()) {
			return mm.Put(s)
		}
	}
	return status.Errorf(codes.Unimplemented, "method Put not implemented")
}

func (m MultiSyncChangesServer) Search(r *SearchSyncChangeRequest, s SyncChanges_SearchServer) error {
	for _, mm := range m {
		if mm.Name() == context1.GetServiceName(s.Context()) {
			return mm.Search(r, s)
		}
	}
	return status.Errorf(codes.Unimplemented, "method Search not implemented")
}
func (m MultiSyncChangesServer) mustEmbedUnimplementedSyncChangesServer() {}
func RegisterMultiSyncChangesServer(s grpc.ServiceRegistrar, srv NamedSyncChangesServer) {
	addr := fmt.Sprintf("%p", s)
	m, ok := multiSyncChangesServers[addr]
	if !ok {
		m = MultiSyncChangesServer{}
		multiSyncChangesServers[addr] = m
		RegisterSyncChangesServer(s, m)
	}
	m = append(m, srv)
}
