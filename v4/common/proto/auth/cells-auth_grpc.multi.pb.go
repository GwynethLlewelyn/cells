// Code generated by protoc-gen-go-grpc. DO NOT EDIT.
// versions:
// - protoc-gen-go-grpc v1.1.0
// - protoc             v3.18.1
// source: cells-auth.proto

package auth

import (
	context "context"
	fmt "fmt"
	context1 "github.com/pydio/cells/v4/common/service/context"
	grpc "google.golang.org/grpc"
	codes "google.golang.org/grpc/codes"
	status "google.golang.org/grpc/status"
)

// This is a compile-time assertion to ensure that this generated file
// is compatible with the grpc package it is being compiled against.
// Requires gRPC-Go v1.32.0 or later.
const _ = grpc.SupportPackageIsVersion7

var (
	multiAuthTokenRevokerServers = make(map[string]MultiAuthTokenRevokerServer)
)

type NamedAuthTokenRevokerServer interface {
	AuthTokenRevokerServer
	Name() string
}
type MultiAuthTokenRevokerServer []NamedAuthTokenRevokerServer

// Revoker invalidates the current token and specifies if the invalidation is due to a refresh or a revokation

func (m MultiAuthTokenRevokerServer) Revoke(ctx context.Context, r *RevokeTokenRequest) (*RevokeTokenResponse, error) {
	for _, mm := range m {
		if mm.Name() == context1.GetServiceName(ctx) {
			return mm.Revoke(ctx, r)
		}
	}
	return nil, status.Errorf(codes.Unimplemented, "method Revoke not implemented")
}
func (m MultiAuthTokenRevokerServer) mustEmbedUnimplementedAuthTokenRevokerServer() {}
func RegisterMultiAuthTokenRevokerServer(s grpc.ServiceRegistrar, srv NamedAuthTokenRevokerServer) {
	addr := fmt.Sprintf("%p", s)
	m, ok := multiAuthTokenRevokerServers[addr]
	if !ok {
		m = MultiAuthTokenRevokerServer{}
		multiAuthTokenRevokerServers[addr] = m
		RegisterAuthTokenRevokerServer(s, m)
	}
	m = append(m, srv)
}

var (
	multiAuthTokenPrunerServers = make(map[string]MultiAuthTokenPrunerServer)
)

type NamedAuthTokenPrunerServer interface {
	AuthTokenPrunerServer
	Name() string
}
type MultiAuthTokenPrunerServer []NamedAuthTokenPrunerServer

// PruneTokens clear revoked tokens

func (m MultiAuthTokenPrunerServer) PruneTokens(ctx context.Context, r *PruneTokensRequest) (*PruneTokensResponse, error) {
	for _, mm := range m {
		if mm.Name() == context1.GetServiceName(ctx) {
			return mm.PruneTokens(ctx, r)
		}
	}
	return nil, status.Errorf(codes.Unimplemented, "method PruneTokens not implemented")
}
func (m MultiAuthTokenPrunerServer) mustEmbedUnimplementedAuthTokenPrunerServer() {}
func RegisterMultiAuthTokenPrunerServer(s grpc.ServiceRegistrar, srv NamedAuthTokenPrunerServer) {
	addr := fmt.Sprintf("%p", s)
	m, ok := multiAuthTokenPrunerServers[addr]
	if !ok {
		m = MultiAuthTokenPrunerServer{}
		multiAuthTokenPrunerServers[addr] = m
		RegisterAuthTokenPrunerServer(s, m)
	}
	m = append(m, srv)
}

var (
	multiLoginProviderServers = make(map[string]MultiLoginProviderServer)
)

type NamedLoginProviderServer interface {
	LoginProviderServer
	Name() string
}
type MultiLoginProviderServer []NamedLoginProviderServer

func (m MultiLoginProviderServer) GetLogin(ctx context.Context, r *GetLoginRequest) (*GetLoginResponse, error) {
	for _, mm := range m {
		if mm.Name() == context1.GetServiceName(ctx) {
			return mm.GetLogin(ctx, r)
		}
	}
	return nil, status.Errorf(codes.Unimplemented, "method GetLogin not implemented")
}

func (m MultiLoginProviderServer) CreateLogin(ctx context.Context, r *CreateLoginRequest) (*CreateLoginResponse, error) {
	for _, mm := range m {
		if mm.Name() == context1.GetServiceName(ctx) {
			return mm.CreateLogin(ctx, r)
		}
	}
	return nil, status.Errorf(codes.Unimplemented, "method CreateLogin not implemented")
}

func (m MultiLoginProviderServer) AcceptLogin(ctx context.Context, r *AcceptLoginRequest) (*AcceptLoginResponse, error) {
	for _, mm := range m {
		if mm.Name() == context1.GetServiceName(ctx) {
			return mm.AcceptLogin(ctx, r)
		}
	}
	return nil, status.Errorf(codes.Unimplemented, "method AcceptLogin not implemented")
}
func (m MultiLoginProviderServer) mustEmbedUnimplementedLoginProviderServer() {}
func RegisterMultiLoginProviderServer(s grpc.ServiceRegistrar, srv NamedLoginProviderServer) {
	addr := fmt.Sprintf("%p", s)
	m, ok := multiLoginProviderServers[addr]
	if !ok {
		m = MultiLoginProviderServer{}
		multiLoginProviderServers[addr] = m
		RegisterLoginProviderServer(s, m)
	}
	m = append(m, srv)
}

var (
	multiConsentProviderServers = make(map[string]MultiConsentProviderServer)
)

type NamedConsentProviderServer interface {
	ConsentProviderServer
	Name() string
}
type MultiConsentProviderServer []NamedConsentProviderServer

func (m MultiConsentProviderServer) GetConsent(ctx context.Context, r *GetConsentRequest) (*GetConsentResponse, error) {
	for _, mm := range m {
		if mm.Name() == context1.GetServiceName(ctx) {
			return mm.GetConsent(ctx, r)
		}
	}
	return nil, status.Errorf(codes.Unimplemented, "method GetConsent not implemented")
}

func (m MultiConsentProviderServer) CreateConsent(ctx context.Context, r *CreateConsentRequest) (*CreateConsentResponse, error) {
	for _, mm := range m {
		if mm.Name() == context1.GetServiceName(ctx) {
			return mm.CreateConsent(ctx, r)
		}
	}
	return nil, status.Errorf(codes.Unimplemented, "method CreateConsent not implemented")
}

func (m MultiConsentProviderServer) AcceptConsent(ctx context.Context, r *AcceptConsentRequest) (*AcceptConsentResponse, error) {
	for _, mm := range m {
		if mm.Name() == context1.GetServiceName(ctx) {
			return mm.AcceptConsent(ctx, r)
		}
	}
	return nil, status.Errorf(codes.Unimplemented, "method AcceptConsent not implemented")
}
func (m MultiConsentProviderServer) mustEmbedUnimplementedConsentProviderServer() {}
func RegisterMultiConsentProviderServer(s grpc.ServiceRegistrar, srv NamedConsentProviderServer) {
	addr := fmt.Sprintf("%p", s)
	m, ok := multiConsentProviderServers[addr]
	if !ok {
		m = MultiConsentProviderServer{}
		multiConsentProviderServers[addr] = m
		RegisterConsentProviderServer(s, m)
	}
	m = append(m, srv)
}

var (
	multiLogoutProviderServers = make(map[string]MultiLogoutProviderServer)
)

type NamedLogoutProviderServer interface {
	LogoutProviderServer
	Name() string
}
type MultiLogoutProviderServer []NamedLogoutProviderServer

func (m MultiLogoutProviderServer) CreateLogout(ctx context.Context, r *CreateLogoutRequest) (*CreateLogoutResponse, error) {
	for _, mm := range m {
		if mm.Name() == context1.GetServiceName(ctx) {
			return mm.CreateLogout(ctx, r)
		}
	}
	return nil, status.Errorf(codes.Unimplemented, "method CreateLogout not implemented")
}

func (m MultiLogoutProviderServer) AcceptLogout(ctx context.Context, r *AcceptLogoutRequest) (*AcceptLogoutResponse, error) {
	for _, mm := range m {
		if mm.Name() == context1.GetServiceName(ctx) {
			return mm.AcceptLogout(ctx, r)
		}
	}
	return nil, status.Errorf(codes.Unimplemented, "method AcceptLogout not implemented")
}
func (m MultiLogoutProviderServer) mustEmbedUnimplementedLogoutProviderServer() {}
func RegisterMultiLogoutProviderServer(s grpc.ServiceRegistrar, srv NamedLogoutProviderServer) {
	addr := fmt.Sprintf("%p", s)
	m, ok := multiLogoutProviderServers[addr]
	if !ok {
		m = MultiLogoutProviderServer{}
		multiLogoutProviderServers[addr] = m
		RegisterLogoutProviderServer(s, m)
	}
	m = append(m, srv)
}

var (
	multiAuthCodeProviderServers = make(map[string]MultiAuthCodeProviderServer)
)

type NamedAuthCodeProviderServer interface {
	AuthCodeProviderServer
	Name() string
}
type MultiAuthCodeProviderServer []NamedAuthCodeProviderServer

func (m MultiAuthCodeProviderServer) CreateAuthCode(ctx context.Context, r *CreateAuthCodeRequest) (*CreateAuthCodeResponse, error) {
	for _, mm := range m {
		if mm.Name() == context1.GetServiceName(ctx) {
			return mm.CreateAuthCode(ctx, r)
		}
	}
	return nil, status.Errorf(codes.Unimplemented, "method CreateAuthCode not implemented")
}
func (m MultiAuthCodeProviderServer) mustEmbedUnimplementedAuthCodeProviderServer() {}
func RegisterMultiAuthCodeProviderServer(s grpc.ServiceRegistrar, srv NamedAuthCodeProviderServer) {
	addr := fmt.Sprintf("%p", s)
	m, ok := multiAuthCodeProviderServers[addr]
	if !ok {
		m = MultiAuthCodeProviderServer{}
		multiAuthCodeProviderServers[addr] = m
		RegisterAuthCodeProviderServer(s, m)
	}
	m = append(m, srv)
}

var (
	multiAuthTokenVerifierServers = make(map[string]MultiAuthTokenVerifierServer)
)

type NamedAuthTokenVerifierServer interface {
	AuthTokenVerifierServer
	Name() string
}
type MultiAuthTokenVerifierServer []NamedAuthTokenVerifierServer

// Verifies a token and returns claims

func (m MultiAuthTokenVerifierServer) Verify(ctx context.Context, r *VerifyTokenRequest) (*VerifyTokenResponse, error) {
	for _, mm := range m {
		if mm.Name() == context1.GetServiceName(ctx) {
			return mm.Verify(ctx, r)
		}
	}
	return nil, status.Errorf(codes.Unimplemented, "method Verify not implemented")
}
func (m MultiAuthTokenVerifierServer) mustEmbedUnimplementedAuthTokenVerifierServer() {}
func RegisterMultiAuthTokenVerifierServer(s grpc.ServiceRegistrar, srv NamedAuthTokenVerifierServer) {
	addr := fmt.Sprintf("%p", s)
	m, ok := multiAuthTokenVerifierServers[addr]
	if !ok {
		m = MultiAuthTokenVerifierServer{}
		multiAuthTokenVerifierServers[addr] = m
		RegisterAuthTokenVerifierServer(s, m)
	}
	m = append(m, srv)
}

var (
	multiAuthCodeExchangerServers = make(map[string]MultiAuthCodeExchangerServer)
)

type NamedAuthCodeExchangerServer interface {
	AuthCodeExchangerServer
	Name() string
}
type MultiAuthCodeExchangerServer []NamedAuthCodeExchangerServer

func (m MultiAuthCodeExchangerServer) Exchange(ctx context.Context, r *ExchangeRequest) (*ExchangeResponse, error) {
	for _, mm := range m {
		if mm.Name() == context1.GetServiceName(ctx) {
			return mm.Exchange(ctx, r)
		}
	}
	return nil, status.Errorf(codes.Unimplemented, "method Exchange not implemented")
}
func (m MultiAuthCodeExchangerServer) mustEmbedUnimplementedAuthCodeExchangerServer() {}
func RegisterMultiAuthCodeExchangerServer(s grpc.ServiceRegistrar, srv NamedAuthCodeExchangerServer) {
	addr := fmt.Sprintf("%p", s)
	m, ok := multiAuthCodeExchangerServers[addr]
	if !ok {
		m = MultiAuthCodeExchangerServer{}
		multiAuthCodeExchangerServers[addr] = m
		RegisterAuthCodeExchangerServer(s, m)
	}
	m = append(m, srv)
}

var (
	multiPasswordCredentialsTokenServers = make(map[string]MultiPasswordCredentialsTokenServer)
)

type NamedPasswordCredentialsTokenServer interface {
	PasswordCredentialsTokenServer
	Name() string
}
type MultiPasswordCredentialsTokenServer []NamedPasswordCredentialsTokenServer

func (m MultiPasswordCredentialsTokenServer) PasswordCredentialsToken(ctx context.Context, r *PasswordCredentialsTokenRequest) (*PasswordCredentialsTokenResponse, error) {
	for _, mm := range m {
		if mm.Name() == context1.GetServiceName(ctx) {
			return mm.PasswordCredentialsToken(ctx, r)
		}
	}
	return nil, status.Errorf(codes.Unimplemented, "method PasswordCredentialsToken not implemented")
}
func (m MultiPasswordCredentialsTokenServer) mustEmbedUnimplementedPasswordCredentialsTokenServer() {}
func RegisterMultiPasswordCredentialsTokenServer(s grpc.ServiceRegistrar, srv NamedPasswordCredentialsTokenServer) {
	addr := fmt.Sprintf("%p", s)
	m, ok := multiPasswordCredentialsTokenServers[addr]
	if !ok {
		m = MultiPasswordCredentialsTokenServer{}
		multiPasswordCredentialsTokenServers[addr] = m
		RegisterPasswordCredentialsTokenServer(s, m)
	}
	m = append(m, srv)
}

var (
	multiAuthTokenRefresherServers = make(map[string]MultiAuthTokenRefresherServer)
)

type NamedAuthTokenRefresherServer interface {
	AuthTokenRefresherServer
	Name() string
}
type MultiAuthTokenRefresherServer []NamedAuthTokenRefresherServer

func (m MultiAuthTokenRefresherServer) Refresh(ctx context.Context, r *RefreshTokenRequest) (*RefreshTokenResponse, error) {
	for _, mm := range m {
		if mm.Name() == context1.GetServiceName(ctx) {
			return mm.Refresh(ctx, r)
		}
	}
	return nil, status.Errorf(codes.Unimplemented, "method Refresh not implemented")
}
func (m MultiAuthTokenRefresherServer) mustEmbedUnimplementedAuthTokenRefresherServer() {}
func RegisterMultiAuthTokenRefresherServer(s grpc.ServiceRegistrar, srv NamedAuthTokenRefresherServer) {
	addr := fmt.Sprintf("%p", s)
	m, ok := multiAuthTokenRefresherServers[addr]
	if !ok {
		m = MultiAuthTokenRefresherServer{}
		multiAuthTokenRefresherServers[addr] = m
		RegisterAuthTokenRefresherServer(s, m)
	}
	m = append(m, srv)
}

var (
	multiPersonalAccessTokenServiceServers = make(map[string]MultiPersonalAccessTokenServiceServer)
)

type NamedPersonalAccessTokenServiceServer interface {
	PersonalAccessTokenServiceServer
	Name() string
}
type MultiPersonalAccessTokenServiceServer []NamedPersonalAccessTokenServiceServer

func (m MultiPersonalAccessTokenServiceServer) Generate(ctx context.Context, r *PatGenerateRequest) (*PatGenerateResponse, error) {
	for _, mm := range m {
		if mm.Name() == context1.GetServiceName(ctx) {
			return mm.Generate(ctx, r)
		}
	}
	return nil, status.Errorf(codes.Unimplemented, "method Generate not implemented")
}

func (m MultiPersonalAccessTokenServiceServer) Revoke(ctx context.Context, r *PatRevokeRequest) (*PatRevokeResponse, error) {
	for _, mm := range m {
		if mm.Name() == context1.GetServiceName(ctx) {
			return mm.Revoke(ctx, r)
		}
	}
	return nil, status.Errorf(codes.Unimplemented, "method Revoke not implemented")
}

func (m MultiPersonalAccessTokenServiceServer) List(ctx context.Context, r *PatListRequest) (*PatListResponse, error) {
	for _, mm := range m {
		if mm.Name() == context1.GetServiceName(ctx) {
			return mm.List(ctx, r)
		}
	}
	return nil, status.Errorf(codes.Unimplemented, "method List not implemented")
}
func (m MultiPersonalAccessTokenServiceServer) mustEmbedUnimplementedPersonalAccessTokenServiceServer() {
}
func RegisterMultiPersonalAccessTokenServiceServer(s grpc.ServiceRegistrar, srv NamedPersonalAccessTokenServiceServer) {
	addr := fmt.Sprintf("%p", s)
	m, ok := multiPersonalAccessTokenServiceServers[addr]
	if !ok {
		m = MultiPersonalAccessTokenServiceServer{}
		multiPersonalAccessTokenServiceServers[addr] = m
		RegisterPersonalAccessTokenServiceServer(s, m)
	}
	m = append(m, srv)
}
