// Code generated by protoc-gen-go-grpc. DO NOT EDIT.
// versions:
// - protoc-gen-go-grpc v1.1.0
// - protoc             v3.18.1
// source: cells-registry.proto

package registry

import (
	context "context"
	fmt "fmt"
	grpc "google.golang.org/grpc"
	codes "google.golang.org/grpc/codes"
	metadata "google.golang.org/grpc/metadata"
	status "google.golang.org/grpc/status"
)

// This is a compile-time assertion to ensure that this generated file
// is compatible with the grpc package it is being compiled against.
// Requires gRPC-Go v1.32.0 or later.
const _ = grpc.SupportPackageIsVersion7

var (
	enhancedRegistryServers = make(map[string]RegistryEnhancedServer)
)

type NamedRegistryServer interface {
	RegistryServer
	Name() string
}
type RegistryEnhancedServer map[string]NamedRegistryServer

func (m RegistryEnhancedServer) StartService(ctx context.Context, r *StartServiceRequest) (*EmptyResponse, error) {
	md, ok := metadata.FromIncomingContext(ctx)
	if !ok || len(md.Get("targetname")) == 0 {
		return nil, status.Errorf(codes.FailedPrecondition, "method StartService should have a context")
	}
	for _, mm := range m {
		if mm.Name() == md.Get("targetname")[0] {
			return mm.StartService(ctx, r)
		}
	}
	return nil, status.Errorf(codes.Unimplemented, "method StartService not implemented")
}

func (m RegistryEnhancedServer) StopService(ctx context.Context, r *StopServiceRequest) (*EmptyResponse, error) {
	md, ok := metadata.FromIncomingContext(ctx)
	if !ok || len(md.Get("targetname")) == 0 {
		return nil, status.Errorf(codes.FailedPrecondition, "method StopService should have a context")
	}
	for _, mm := range m {
		if mm.Name() == md.Get("targetname")[0] {
			return mm.StopService(ctx, r)
		}
	}
	return nil, status.Errorf(codes.Unimplemented, "method StopService not implemented")
}

func (m RegistryEnhancedServer) GetService(ctx context.Context, r *GetServiceRequest) (*GetServiceResponse, error) {
	md, ok := metadata.FromIncomingContext(ctx)
	if !ok || len(md.Get("targetname")) == 0 {
		return nil, status.Errorf(codes.FailedPrecondition, "method GetService should have a context")
	}
	for _, mm := range m {
		if mm.Name() == md.Get("targetname")[0] {
			return mm.GetService(ctx, r)
		}
	}
	return nil, status.Errorf(codes.Unimplemented, "method GetService not implemented")
}

func (m RegistryEnhancedServer) RegisterService(ctx context.Context, r *Service) (*EmptyResponse, error) {
	md, ok := metadata.FromIncomingContext(ctx)
	if !ok || len(md.Get("targetname")) == 0 {
		return nil, status.Errorf(codes.FailedPrecondition, "method RegisterService should have a context")
	}
	for _, mm := range m {
		if mm.Name() == md.Get("targetname")[0] {
			return mm.RegisterService(ctx, r)
		}
	}
	return nil, status.Errorf(codes.Unimplemented, "method RegisterService not implemented")
}

func (m RegistryEnhancedServer) DeregisterService(ctx context.Context, r *Service) (*EmptyResponse, error) {
	md, ok := metadata.FromIncomingContext(ctx)
	if !ok || len(md.Get("targetname")) == 0 {
		return nil, status.Errorf(codes.FailedPrecondition, "method DeregisterService should have a context")
	}
	for _, mm := range m {
		if mm.Name() == md.Get("targetname")[0] {
			return mm.DeregisterService(ctx, r)
		}
	}
	return nil, status.Errorf(codes.Unimplemented, "method DeregisterService not implemented")
}

func (m RegistryEnhancedServer) ListServices(ctx context.Context, r *ListServicesRequest) (*ListServicesResponse, error) {
	md, ok := metadata.FromIncomingContext(ctx)
	if !ok || len(md.Get("targetname")) == 0 {
		return nil, status.Errorf(codes.FailedPrecondition, "method ListServices should have a context")
	}
	for _, mm := range m {
		if mm.Name() == md.Get("targetname")[0] {
			return mm.ListServices(ctx, r)
		}
	}
	return nil, status.Errorf(codes.Unimplemented, "method ListServices not implemented")
}

func (m RegistryEnhancedServer) WatchServices(r *WatchServicesRequest, s Registry_WatchServicesServer) error {
	md, ok := metadata.FromIncomingContext(s.Context())
	if !ok || len(md.Get("targetname")) == 0 {
		return status.Errorf(codes.FailedPrecondition, "method WatchServices should have a context")
	}
	for _, mm := range m {
		if mm.Name() == md.Get("targetname")[0] {
			return mm.WatchServices(r, s)
		}
	}
	return status.Errorf(codes.Unimplemented, "method WatchServices not implemented")
}

func (m RegistryEnhancedServer) RegisterNode(ctx context.Context, r *Node) (*EmptyResponse, error) {
	md, ok := metadata.FromIncomingContext(ctx)
	if !ok || len(md.Get("targetname")) == 0 {
		return nil, status.Errorf(codes.FailedPrecondition, "method RegisterNode should have a context")
	}
	for _, mm := range m {
		if mm.Name() == md.Get("targetname")[0] {
			return mm.RegisterNode(ctx, r)
		}
	}
	return nil, status.Errorf(codes.Unimplemented, "method RegisterNode not implemented")
}

func (m RegistryEnhancedServer) DeregisterNode(ctx context.Context, r *Node) (*EmptyResponse, error) {
	md, ok := metadata.FromIncomingContext(ctx)
	if !ok || len(md.Get("targetname")) == 0 {
		return nil, status.Errorf(codes.FailedPrecondition, "method DeregisterNode should have a context")
	}
	for _, mm := range m {
		if mm.Name() == md.Get("targetname")[0] {
			return mm.DeregisterNode(ctx, r)
		}
	}
	return nil, status.Errorf(codes.Unimplemented, "method DeregisterNode not implemented")
}

func (m RegistryEnhancedServer) GetNode(ctx context.Context, r *GetNodeRequest) (*GetNodeResponse, error) {
	md, ok := metadata.FromIncomingContext(ctx)
	if !ok || len(md.Get("targetname")) == 0 {
		return nil, status.Errorf(codes.FailedPrecondition, "method GetNode should have a context")
	}
	for _, mm := range m {
		if mm.Name() == md.Get("targetname")[0] {
			return mm.GetNode(ctx, r)
		}
	}
	return nil, status.Errorf(codes.Unimplemented, "method GetNode not implemented")
}

func (m RegistryEnhancedServer) ListNodes(ctx context.Context, r *ListNodesRequest) (*ListNodesResponse, error) {
	md, ok := metadata.FromIncomingContext(ctx)
	if !ok || len(md.Get("targetname")) == 0 {
		return nil, status.Errorf(codes.FailedPrecondition, "method ListNodes should have a context")
	}
	for _, mm := range m {
		if mm.Name() == md.Get("targetname")[0] {
			return mm.ListNodes(ctx, r)
		}
	}
	return nil, status.Errorf(codes.Unimplemented, "method ListNodes not implemented")
}
func (m RegistryEnhancedServer) mustEmbedUnimplementedRegistryServer() {}
func RegisterRegistryEnhancedServer(s grpc.ServiceRegistrar, srv NamedRegistryServer) {
	addr := fmt.Sprintf("%p", s)
	m, ok := enhancedRegistryServers[addr]
	if !ok {
		m = RegistryEnhancedServer{}
		enhancedRegistryServers[addr] = m
		RegisterRegistryServer(s, m)
	}
	m[srv.Name()] = srv
}
func DeregisterRegistryEnhancedServer(s grpc.ServiceRegistrar, name string) {
	addr := fmt.Sprintf("%p", s)
	m, ok := enhancedRegistryServers[addr]
	if !ok {
		return
	}
	delete(m, name)
}
